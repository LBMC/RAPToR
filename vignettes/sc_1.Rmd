```{r, include = FALSE, eval = T}
knitr::opts_knit$set(out.format = "html", header = "")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  out.width = '100%',
  cache=T
)
options(width=100)

gen_figs <- T

transp <- function(col, a=.5){
  colr <- col2rgb(col)
  return(rgb(colr[1,], colr[2,], colr[3,], a*255, maxColorValue = 255))
}
```


Including estimated age as a covariate in Differential Expression (DE) analysis can substantially reduce previously unexplained variation between samples. 
This results in better model fits and consequently better power to detect DE genes. 
In this section, we show that even time-series designs benefit from this approach thanks to unsynchronized replicates.


## Data and strategy

@lehrbach2012post profiled *C. elegans* wild-type (`wt`) and *pash-1(mj100)* mutants (`mut`) at 4 time points (0, 6, 12, and 24 hours past the L4 stage), each in triplicate (Accession: [E-MTAB-1333](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-1333/)). Code to generate the `dslehrbach2012` object can be found [at the end of this section](#code-to-generate-dslehrbach2012). 

Given the time-series experimental design, finding Differential Expression (DE) of genes between strains requires including development in the model.
This is true in any time series context, even more here because late-larval development of *C. elegans* is known for drastic changes in gene expression within a short time frame (@snoek2014rapid).

```{r sc1_libload, message=FALSE, warning=FALSE}
library(RAPToR)
library(wormRef)

library(stats)
library(parallel)
library(limma)

# for plotting
library(RColorBrewer)
library(beeswarm)
library(vioplot)
```


<br>


```{r sc1_load, include=F, eval=gen_figs}
load("../inst/extdata/dslerhbach2012.RData")
```




## Estimating sample age

We start by applying a quantile-normalization and $log(X+1)$ transformation to the data.

```{r sc1_qnormlog, eval = gen_figs}
dslehrbach2012$g <- limma::normalizeBetweenArrays(dslehrbach2012$g, method = "quantile")
dslehrbach2012$g <- log1p(dslehrbach2012$g)
```

Next, we select a reference and stage the samples. Since sample (chronological) age ranges from the fourth larval molt (L4) to 24h past L4, we select `Cel_YA_2` from `wormRef` that covers this range.

```{r sc1_ae_lb, eval=gen_figs,  class.source = 'fold-show'}
# load reference
r_ya <- prepare_refdata("Cel_YA_2", "wormRef", 400)

# estimate sample age
ae_lerhbach <- ae(dslehrbach2012$g, r_ya)
```



```{r sc1_plot_ae, fig.width=7, fig.height=5, echo = F, out.width="80%", class.source = 'fold-show'}
plot(ae_lerhbach, groups = as.factor(dslehrbach2012$p$tpastL4),
     main = "Lerhbach et al. (2012) samples, grouped by time point",
     subset = rev(1:24), lmar = 7, col = c(2,1)[dslehrbach2012$p$strain])
```

We can see quite a lot of variation in the sample timings, especially at the 0- and 6-hour time points.


Another curious effect can be noted, easier to see when grouping the samples by batch 
In the first two replicates, mutants are systematically (and statistically significantly) older than WT, while the opposite effect is true for the third replicate.


```{r sc1_stat_batch, class.source = 'fold-show'}
# compute age difference between wt & mut at each time point
isWT <- dslehrbach2012$p$strain=="wt"
ae_dif <- ae_lerhbach$age.estimates[isWT,1] - ae_lerhbach$age.estimates[!isWT,1]

# test for effect significance with a linear model
batch <- dslehrbach2012$p$rep[isWT]
summary(lm(ae_dif~batch))$coefficients
```

```{r sc1_plot_ae2, fig.width=10, fig.height=5, echo = F, out.width="100%"}
layout(matrix(1:2, nrow=1), widths = c(.7, .3))
par(mar = c(4,5,3,1))
plot(ae_lerhbach, groups = dslehrbach2012$p$rep, 
     main = "Lerhbach et al. (2012) samples, grouped by batch", 
     subset = rev(1:24), lmar=7, col = c(2,1)[dslehrbach2012$p$strain])

plot(ae_dif~batch, 
     ylab="Estimated age difference\nbetween wt and mut samples (h)", 
     xlab = "Batch", boxwex=.4);abline(h=0, lty=2, col='grey')
```


## Impact of development on gene expression

Gene expression depends so strongly on development that correlation between samples is only predicted by their age difference, rather than by their genetic background. 
The graph below shows correlation between all possible pairs of samples, with no clear effect of strain difference. 

```{r sc1_cor_dev, eval = gen_figs}
cc <- cor(dslehrbach2012$g, dslehrbach2012$g, method = "spearman")
```


```{r sc1_cor_dev_plot, fig.height=5, fig.width=5, echo = F, out.width="60%"}
ut <- upper.tri(cc, diag = F)
ya <- cc[ut]
xa <- abs(ae_lerhbach$age.estimates[col(cc)[ut],1] - ae_lerhbach$age.estimates[row(cc)[ut],1])
cols <- (dslehrbach2012$p$strain[col(cc)[ut]] != dslehrbach2012$p$strain[row(cc)[ut]]) + 1

plot(xa, ya, ylab = "Spearman correlation",
     xlab = "Absolute estimated age difference (h)",
     cex=.5, xlim = range(xa),
     lwd=2, col = cols)
legend("topright", legend = c("same strain", "different strain"), 
       title = "Sample pair of", bty = 'n', inset = .05,
       col = 1:2, pch = 1, lwd = 3, lty = NA, text.font = 2, text.col = 1:2)
```


## Differential Expression analysis

We can perform a simple DE analysis with `limma`, with the following model : 

$$ 
X \sim strain \times \mathtt{ns(age, df = 2)} 
$$

Non-linear expression dynamics are managed by a spline with $\mathtt{ns()}$.

To evaluate the number of DE genes due to development or to strain translates to comparing the following nested models (2 vs. 1 for development, 3 vs. 1 for strain).

$$
\begin{aligned}
Y & = \beta_0 +
\beta_1 I_{strain} +
(\alpha_1 age_{sp1} + \alpha_2 age_{sp2}) +
(\gamma_1 I_{strain} age_{sp1} + \gamma_2 I_{strain} age_{sp2})\\
Y & = \beta_0 + \beta_1 I_{strain}\\
Y & = \beta_0 + (\alpha_1 age_{sp1} + \alpha_2 age_{sp2})
\end{aligned}
$$
We don't consider whether genes are up- or down-regulated, but only the detection of an effect. 
Genes will be considered DE with Benjamini-Holm adjusted p-values $ < 0.05$ for corresponding coefficients.


DE code :

##### Show
```{r sc1_dge_setup_funcs}
# Predictions from limma model
pred_lmFit <- function(Fit){
  tcrossprod(Fit$coefficients, Fit$design)
}

# Compute Goodness of Fit
GoF <- function(Fit, X){
  pred <- pred_lmFit(Fit)
  res <- (X - pred)
  ss <- apply(X, 1, function(ro) sum((ro - mean(ro))^2))
  Rsq <- sapply(seq_len(nrow(X)), function(i){
    1 - sum(res[i,]^2)/ss[i]
  })
  return(Rsq)
}
```

```{r sc1_dge_main_func}
DGE <- function(X, strain, age, df = 2, name = NULL, return.model = FALSE){
  require(splines)
  if(! length(strain) == ncol(X) | ! length(age) == ncol(X))
    stop("strain and age must be of length ncol(X).")
  
  # make pdat df
  pdat <- data.frame(strain = factor(strain), age = as.numeric(age), row.names = colnames(X))
  
  # build design matrix
  d <- model.matrix(~ 1 + ns(age, df = df) * strain, data = pdat) 
  
  # fix colnames
  colnames(d) <- c("b0", paste0(rep("a", df), 1L:df), "strainmut", paste0(rep("strainmut.a", df), 1L:df))
  
  # build contrast matrices for mut and age tests
  if(df == 2){
    cm.mut <- makeContrasts(mut = strainmut, #strainwt - strainmut,
                            mut.i1 = strainmut.a1,
                            mut.i2 = strainmut.a2,
                            levels = d)
    cm.age <- makeContrasts(a1, a2,
                            a.i1 = strainmut.a1,
                            a.i2 = strainmut.a2,
                            levels = d)
  }
  
  if(df == 3){
    cm.mut <- makeContrasts(mut = strainmut, #strainwt - strainmut,
                            mut.i1 = strainmut.a1,
                            mut.i2 = strainmut.a2,
                            mut.i3 = strainmut.a3,
                            levels = d)
    cm.age <- makeContrasts(a1, a2, a3,
                            a.i1 = strainmut.a1,
                            a.i2 = strainmut.a2,
                            a.i3 = strainmut.a3,
                            levels = d)
  }
  
  # fit model
  m.0 <- lmFit(object = X, design = d)
  # get GoF
  gof <- GoF(Fit = m.0, X = X)
  
  # find DE genes for mut
  m.m <- contrasts.fit(m.0, contrasts = cm.mut)
  m.m <- eBayes(m.m)
  
  # find DE genes for age
  m.a <- contrasts.fit(m.0, contrasts = cm.age)
  m.a <- eBayes(m.a)
  
  Tmut <- topTable(m.m, adjust.method = "BH", number = Inf, sort.by = "none")[, c("F", "P.Value", "adj.P.Val")]
  Tage <- topTable(m.a, adjust.method = "BH", number = Inf, sort.by = "none")[, c("F", "P.Value", "adj.P.Val")]
  
  res <- list(gof  = gof,
              tmut = Tmut,
              tage = Tage,
              name = name)
  if(return.model)
    res$model = m.0
  
  rm(m.0, m.m, m.a, Tmut, Tage, d, X, pdat, gof)
  gc(verbose = F)
  return(res)
}
```

<br>
<br>



To determine whether there is an improvement in DE analysis when using age estimates or chronological age, we use  *the same model* with either predictor and compare results.

```{r do_dge, eval = gen_figs, results='hide'}
# format gdata as log2 for limma input
X <- log2(exp(dslehrbach2012$g))

dge.ca <- DGE(X = X, strain = dslehrbach2012$p$strain, age = dslehrbach2012$p$tpastL4, 
              name = "dge.ca", return.model = T)
dge.ae <- DGE(X = X, strain = dslehrbach2012$p$strain, age = ae_lerhbach$age.estimates[,1], 
              name = "dge.ae", return.model = T)
```

```{r sc1_plot_dge_func, echo = F, eval = gen_figs}
plot_DGE_pval_vs <- function(pv.x, pv.y, 
                             xlab = "-log10(pv.x)", ylab = "-log10(pv.y)", 
                             main = "DE genes with pv.x vs pv.y", ...)
{ 
  cols <- rowSums(cbind((pv.x < 0.05), (pv.y < 0.05),
                     (pv.x > 0.05)+1 & (pv.y < 0.05)))+1
  
  plot(-log10(pv.x), -log10(pv.y), cex=.3, pch=16, 
       xlab = xlab, ylab = ylab, main = main,
       col = cols, ...)
  
  abline(v=-log10(0.05), h=-log10(0.05), col=2)
  
  legend('bottomright', legend = paste(table(cols)), text.col = 1:4,
         text.font = 2, horiz = T, bty='n')
  invisible(cols)
}

```

Below, we show adjusted p.values for detection of an effect for each gene, when using chronological or estimate age in the model. Red bars correspond to the 0.05 threshold for significance and gene counts for each quadrant are color-matched.

```{r sc1_plot_dge, echo = F, fig.height=5, fig.width=10}
par(mfrow = c(1,2))
cols <- plot_DGE_pval_vs(dge.ca$tmut$adj.P.Val, dge.ae$tmut$adj.P.Val, main = "Strain effect detection (chron. vs ae)", 
                         xlab = "-log10(pval) with chron. age", ylab = "-log10(pval) with ae")
# plot(dge.ca$gof, dge.ae$gof, pch = 16, cex = .4, col = cols)
# points(dge.ca$gof[cols>1], dge.ae$gof[cols>1], pch = 16, cex = .6, col = cols[cols>1])

cols <- plot_DGE_pval_vs(dge.ca$tage$adj.P.Val, dge.ae$tage$adj.P.Val, main = "Development effect detection (chron. vs ae)",
                         xlab = "-log10(pval) with chron. age", ylab = "-log10(pval) with ae")
# plot(dge.ca$gof, dge.ae$gof, pch = 16, cex = .4, col = cols)
# points(dge.ca$gof[cols>1], dge.ae$gof[cols>1], pch = 16, cex = .6, col = cols[cols>1])
```

```{r dge_increase, eval = gen_figs, results='markup'}
mut_dif.ca <- sum(dge.ca$tmut$adj.P.Val < 0.05)
mut_dif.ae <- sum(dge.ae$tmut$adj.P.Val < 0.05)

age_dif.ca <- sum(dge.ca$tage$adj.P.Val < 0.05)
age_dif.ae <- sum(dge.ae$tage$adj.P.Val < 0.05)

100 * (mut_dif.ae - mut_dif.ca) / (mut_dif.ca) # mut pct increase 
#> [1] 96.39528

100 * (age_dif.ae - age_dif.ca) / (age_dif.ca) # age pct increase
#> [1] 7.674787

```

We detect nearly *twice* as many DE genes for strain using our estimates compared to using the chronological age, and around $8\%$ more genes with development. 
This, along with the large proportion of genes changing with development ($57 - 62\%$) compared to strain ($7-16\%$) shows how crucial it is to properly include developmental dynamics in DE analyses.



This increase in DE genes is partially explained by better model fits, shown below by the goodness-of-fit (GoF) distribution across genes. The goodness-of-fit (GoF) computed is an $R^2 = 1 - \frac{SS_{res}}{SS_{tot}}$ per gene.

```{r sc1_gof_dist, echo = F, fig.height=4, fig.width=6, out.width="60%"}
d.ca <- density(dge.ca$gof, from = 0, to = 1)
d.ae <- density(dge.ae$gof, from = 0, to = 1)

plot(d.ca$x, d.ca$y, type = "l", lwd = 3, ylim = range(c(d.ca$y, d.ae$y)), 
     xlab = "GoF", col = "red", ylab = "Density", main = paste("Model Goodness of Fit distribution across",nrow(X),"genes"))
points(d.ae$x, d.ae$y, type = 'l', col = "blue", lwd = 3) 
legend("bottom", lwd = 4, col = c("red", "blue"), title = "Model with",
       legend = c("Chronological age", "Estimated age"), title.col = "black",
       text.font = 2, text.col = c("red", "blue"), bty = 'n')
```


## Comparing model fit between chronological age, estimated age, and random noise on chronological age


If the asynchronicity we observe in age estimates is erroneous, then using random noise around the chronological age values should yield similar results to using our age estimates in the model.
To test this, we can simulate age sets with added noise of similar distribution to the age differences observed between chronological and estimated age.

As done above, we compare results with the model goodness-of-fit (GoF) per gene: an $R^2 = 1 - \frac{SS_{res}}{SS_{tot}}$.

We also look at the number of DE genes found for strain and development (defined as those with a BH-adjusted p.value below 0.05).

```{r sc1_comp_dge1, eval = gen_figs}
age_diffs <- (dslehrbach2012$p$tpastL4 + 50) - ae_lerhbach$age.estimates[,1]
# Note : + 50 to shift tpastL4 to age, avoiding generation of negative tpastl4 values,
#        this has no impact on the DGE analysis (it just shifts the age window).

# estimate density function of age_diffs
d_ad <- density(age_diffs)

# generate age sets of with random age_diffs-like noise 
set.seed(10)

n <- 100
rd_ages <- lapply(seq_len(n), function(i){
  (dslehrbach2012$p$tpastL4 + 50) + sample(x = d_ad$x, size = nrow(dslehrbach2012$p), prob = d_ad$y, replace = T) 
})

```


```{r sc1_comp_dge1bis, eval = F, include = F}
# plot(density(unlist(lapply(rd_ages, function(a) a - 50- dslehrbach2012$p$tpastL4))))
hist(unlist(lapply(rd_ages, function(a) a - 50 - dslehrbach2012$p$tpastL4)),
     border = transp(1, 0.4), breaks = 50, freq = F, 
     main = "Simulated age differences", xlab = "Age difference")
points(d_ad, type = 'l', lwd = 3)
legend("topright", legend = "Density of age_diffs", lwd = 3, bty = "n")
# hist(age_diffs, col = transp(4), freq = F, add = T,
#      breaks = 20)
# plot(dslehrbach2012$p$tpastL4, ae_lerhbach$age.estimates[,1], type = "n", ylim = range(rd_ages))
# points(dslehrbach2012$p$tpastL4, ae_lerhbach$age.estimates[,1], col = 4, lwd = 2)
```


```{r sc1_comp_dge2, eval = gen_figs, results='hide'}
# setup cluster for parallelization
cl <- makeCluster(3, "FORK")

# do DGE on all age sets
rd_dges <- parLapply(cl, seq_len(n), function(i){
  cat("\r", i,"/",n)
  DGE(X, dslehrbach2012$p$strain, rd_ages[[i]], name = paste0("rd.",i))
})

stopCluster(cl)
gc()
```


```{r sc1_format_forplot, echo = F, eval=gen_figs}
qts <- seq(0,1, length.out = 100)
quants <- lapply(seq_len(n), function(i){
  quantile(rd_dges[[i]]$gof, probs = qts)
})
quants <- do.call(rbind, quants)
```

```{r sc1_plot_resdge, echo = F, fig.height=6, fig.width=10}
layout(mat = matrix(c(2,3,1,1), ncol = 2), widths = c(.45,.55))

plot(0:1, 0:1, type = "n", ylab = "GoF >= quantile", xlab = "quantile", main = "QQ-plot of Goodness of Fit distribution")
invisible(apply(quants, 1, function(ro) points(qts, ro, type = 'l', col = transp("black", a = .4))))
points(qts, quantile(dge.ca$gof, probs = qts), type = "l", lwd = 4, col = 2)
points(qts, quantile(dge.ae$gof, probs = qts), type = "l", lwd = 4, col = 4)

legend('bottomright', legend = c("Chronological age", "Estimated age", "Chron.Age + noise"), 
       col = c(2,4, 1), lwd = c(4,4,1), bty = "n")


diffgens <- lapply(seq_len(n), function(i){
  data.frame(mut = sum(rd_dges[[i]]$tmut$adj.P.Val < 0.05), age = sum(rd_dges[[i]]$tage$adj.P.Val < 0.05))
})

diffgens <- do.call(rbind, diffgens)

hist(diffgens$mut, breaks = 50, main = "Nb of DE genes for strain", xlim = c(0,3500), xlab = "Nb. genes")
abline(v = sum(dge.ca$tmut$adj.P.Val < 0.05), lwd = 3, col = 2)
abline(v = sum(dge.ae$tmut$adj.P.Val < 0.05), lwd = 3, col = 4)

hist(diffgens$age, breaks = 50, xlim = c(min(diffgens$age), 12000), main = "Nb of DE genes for devpt.", xlab = "Nb. genes")
abline(v = sum(dge.ca$tage$adj.P.Val < 0.05), lwd = 3, col = 2)
abline(v = sum(dge.ae$tage$adj.P.Val < 0.05), lwd = 3, col = 4)
```

We can see that using the estimated age leads to better model fits and increased detection of DE genes both for strain and along development.

Below, GoF distributions ordered by chronological age quantiles (binned along the quantile scale) and shown as boxplots also clearly show that for the same genes, we tend to have better fits with estimated age than chronological age, while that is not the case when adding noise.

```{r sc1_plot_resdge2, echo = F, eval = gen_figs}
ord <- order(dge.ca$gof)
# par(mfrow = c(1,1))
# plot(dge.ca$gof[ord], type = 'l')


gofs <- lapply(seq_len(n), function(i){
  rd_dges[[i]]$gof[ord]
})
gofs <- do.call(rbind, gofs)
```

```{r sc1_plot_resdge3, echo = F, eval = gen_figs}
plot_QQGoFbox <- function(gof, bins = 10, at = seq(0,1,l = bins), boxwex = .5/bins, add = F, plotargs = list(), ...){
  grps <- cut(1:length(gof), bins)
  
  bxs <- lapply(levels(grps), function(l){
    s <- which(grps == l)
    return(boxplot(gof[s], plot = F))
  })
  if(!add){
    do.call(plot, c(list(x = range(at), y=range(gof), type = "n"), plotargs))
  }
  
  invisible(lapply(seq_len(bins), function(i){
    bxp(z = bxs[[i]], at = at[i], add = T, frame.plot = F, axes = F, boxwex = boxwex, ...)
  }))
}
```

```{r sc1_plot_resdge4, echo = F, fig.height=8, fig.width=16}
par(mfrow = c(1,2), mar = c(4,4,4,1))
plot(0:1, 0:1, type = "n", ylab = "GoF", xlab = "quantile", main = "Goodness of Fit distribution in chron. age quantile order\n(estimated age)")
points(qts, quantile(dge.ca$gof, probs = qts), type = "l", lwd = 4, col = 2)
plot_QQGoFbox(dge.ae$gof[ord], bins = 50, add = T, cex = .2, lwd = 1, boxcol=4, medcol = 4, medlwd=6, boxwex = .8/50)

legend('bottomright', legend = c("Chronological age GoF quantiles"), 
       col = c(2), lwd = c(4), bty = "n")


plot(0:1, 0:1, type = "n", ylab = "GoF >= quantile", xlab = "quantile", main = paste0("Goodness of Fit distribution in chron. age quantile order\n(joined simulated age + noise sets, n = ",n, ")"))
points(qts, quantile(dge.ca$gof, probs = qts), type = "l", lwd = 4, col = 2)
plot_QQGoFbox(c(gofs), bins = 50, add = T, cex = .2, lwd = 1, boxwex = .8/50)
```





## Code to generate `dslehrbach2012` :
<a name="code-gen_ds1-ds2"></a>
  
```{r sc1_load_namespaces, eval = F}
data_folder <- "../inst/extdata/"

library("biomaRt") # May need to be installed with bioconductor
library("limma")   # ..
library("affy")    # ..
library("gcrma")   # ..

requireNamespace("wormRef", quietly = T)
requireNamespace("utils", quietly = T)
```
**Note : set the `data_folder` variable to an existing path on your system where you want to store the objects.**

###### `dslehrbach202`
```{r sc1_load_dslehrbach_c, code = readLines("load_dslehrbach2012.R"), echo = TRUE, eval = FALSE}
```

