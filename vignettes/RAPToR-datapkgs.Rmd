---
title: "`RAPToR` - Data-packages"
output: 
  rmarkdown::html_document :
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{RAPToR-datapkgs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
author: Romain Bulteau
date: "`r format(Sys.Date(), '%B %Y')`"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  out.width = '100%'
)
options(width=100)

library(RAPToR)
```

# Who is this vignette for ?

This vignette is for those who've already familiarized themselves with [`RAPToR` reference building](RAPToR-refbuilding.html).
It's also for me to keep track of how to continue improving the tool with new references.

This vignette is useful if you've already built a few references and want to make them available to the world (or use them more easily yourself).

You will need some knowledge of R package development. Data-packages are, after all, *packages*. 
This document only details how to set up your data-package to interact properly with `RAPToR`.


# What's a data-package ?

By definition, a "data-package" is an R package in which you store large datasets (over a few Mo, at least).
This is a good practice for several reasons. 

 1. If your data rarely or never changes, updates to the data-package (and thus, download of the data) will be minimal. If included in a standard package, large data can be a burden during install.
 1. The data may never be used. Why have users download data they won't need ?
 1. CRAN standards limit package size to 5MB (documentation included). A large dataset is better off when separated from methods and functions that may need it.
 
Hadley Wickam gives thorough advice on organizing data in packages in his [*R packages* book](http://r-pkgs.had.co.nz/data.html).


# RAPToR data-packages

`RAPToR` relies on references to operate. 
These references sometimes being tedious to build, we want to give access to pre-built references for users, which can be quite large.
Here, a reference corresponds to a pre-processed gene expression dataset, its optimal interpolation parameters, and some metadata.

To avoid overcharging the end user, we split references to data-packages.
The data is then used through the `RAPToR` interface described below.

## References
The references are stored as `.RData` objects. 
You can put as many as you like in one data-package (I try to keep one data-package per organism).
These objects should include everything needed to construct the interpolated reference (*e.g.* gene expression matrix, phenotypic data, model formula and parameters).

Being consistent, clear and concise with naming can help users (or even you !) find their way around your references.
For example, `wormRef` references are named with an organism code `Cel` (*C. elegans*) followed by the developmental period covered by the reference *e.g.* `larval`.


An example of the structure of the `Cel_larval` reference object is detailed below.

A list with

 * `$ g` The gene expression matrix (genes as rows, samples as columns).
 * `$ p` A dataframe of phenotypic data on the samples :
   * `sname` sample names,
   * `age`   *developmental* age of the samples (scaled),
   * `cov`   covariate, factor indicating which of 3 time series,
   * `age_ini`  *chronological* age of the samples,
   * `accession` sample accession ID for GEO.
 * `$ geim_params`  A list with necessary information for interpolation :
   * `$ formula = "X ~ s(age, bs = 'ds') + cov"`
   * `$ method = "gam"`
   * `$ dim_red = "pca"`
   * `$ nc = 40`
 * `$ t.unit = "h past egg-laying (20C)"` the time unit.
 * `$ cov.levels` A named list with covariate levels to interpolate as.
   *`$ cov = "O.20"`
 * `$ metadata` A named list with any extra metadata
   * `$ organism = "C. elegans"`
   * `$ profiling = "whole-organism, bulk"`
   * `$ technology = "RNAseq"`



**Document the references.** It is standard practice to document data.
*What is the data ? Where is the data from ?* etc.

## Data-package interface with RAPToR

We've set up a standard system using reference names, so that users can access data-package information transparently from `RAPToR`.

The following objects are **necessary** for the interface to work.


### `.prepref_` functions

The `.prepref_` functions (note the "dot") are the key of this interface : they **prep**are the **ref**erence for the user.
They are functions that must respect the naming convention `.prepref_ref_name()` (*e.g.* `.prepref_Cel_larval()`) *and* take `n.inter` or `by.inter` as arguments.

These are the backbone called by `prepare_refdata()` when fetching a reference.
The functions must output the reference `ref` object, with the specified parameters.
This means building the GEIM model, and calling `make_ref()` with the appropriate parameters and metadata. 

We have made a [function factory](https://adv-r.hadley.nz/function-factories.html) to generate these functions. 
It inputs the reference data object described above, and returns the corresponding prepref function. 
```{r prepref, eval = F}
.prepref_skel <- function(data, from=NULL, to=NULL){
  # .prepref function factory
  f <- function(n.inter=NULL, by.inter=NULL){
    m <- RAPToR::ge_im(
      X = data$g,
      p = data$p,
      formula = data$geim_params$formula,
      method = data$geim_params$method,
      dim_red = data$geim_params$dim_red,
      nc = data$geim_params$nc
    )
    return(RAPToR::make_ref(m, 
                            n.inter = n.inter,
                            by.inter = by.inter,
                            from = from, 
                            to = to,
                            t.unit = data$t.unit,
                            cov.levels = data$cov.levels,
                            metadata = data$metadata)
    )
  }
  return(f)
}
```

To make `.prepref_Cel_larval()`, we simply have to do include the following code in the data-package, along with the function factory.

```{r prepref_larv, eval=F}
.prepref_Cel_larval <- .prepref_skel(wormRef::Cel_larval)
```


### `ref_list` object

`RAPToR` expects a `ref_list` object in the data-package. 
This is what's displayed when calling the `list_refs(datapkg)` function.

```{r list_ref, results='markup'}
list_refs(datapkg = "wormRef")
```

You're free to define the form of this object, but be sure to include the reference names somewhere, as the user needs them to access the reference with `prepare_refdata()`.



### `.plot_refs()` function

This one is optional, but very useful to guide users to the correct reference for their samples.
Including a `.plot_refs()` function (note the “dot”) in the data-package will allow it to be called by the `plot_refs(datapkg)` function.

```{r plot_ref, fig.width = 8, fig.height=6, out.width="75%"}
plot_refs(datapkg = "wormRef")
```

### Other objects

You're free to include any extra objects in your data-package that may be useful.
For example, the `wormRef` package has a `Cel_devstages` object with information on key developmental stages of development. 
The data is used for building the plot in `.plot_refs()` (*cf.* above).


<br>
<br>
<br>