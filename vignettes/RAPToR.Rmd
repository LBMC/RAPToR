---
title: "`RAPToR` - Real Age Prediction from Transcriptome staging On Reference"
output: 
  rmarkdown::html_document :
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{RAPToR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
author: Romain Bulteau
date: "`r format(Sys.Date(), '%B %Y')`"
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  out.width = '100%'
)
options(width=100)
gen_figs <- F # wether to generate figures or read from RAPToR-refbuilding_files/figs

figpath <- "../inst/doc/RAPToR_figs/"
if(!file.exists(figpath)){
  dir.create(figpath)
}

library(RAPToR)

library(ggplot2)
library(ggpubr)
requireNamespace("limma", quietly = T)
```

```{r genfig_setup, include = F}
png_custom <- function(figname, path = "", 
                       fig.width = 7, fig.height = 5, res = 150, ...){
  png(filename = paste0(path, figname, ".png"), 
      width = fig.width, height = fig.height, res = res, units = "in")
}

show_fig <- function(figname = knitr::opts_current$get("label"), expr, path = figpath, ...){
  if(gen_figs){
    png_custom(figname = figname, path = figpath, ...)
    eval(expr = expr)
    dev.off()
  }
  else{
    knitr::include_graphics(paste0(path, figname, ".png"))
  }
}

```

<br>
<br>

Gene expression profiling has become standard practice and serves as the basis of many analyses in biology. 
However, gene expression is highly variable during development. 
Unknown and unintended developmental variation among samples can
obscure and confound the effect of variables of interest in a study. 
This is especially a problem for fast-developing organisms such as *Caenorhabditis elegans*, where drastic developmental changes in gene expression occur within hours. 
The developmental speed of such organisms is usually heavily influenced by numerous factors and therefore obtaining developmentally synchronized samples is not trivial. 
Genome-wide gene expression is a very rich source of data, which includes information about the developmental stage of an organism. 
However, methods that extract this information are still lacking.

We present `RAPToR`, a new tool to accurately predict individual samples' developmental age from their gene expression profiles. 
We achieved this by building high-temporal-resolution time series across the entire development from multiple available datasets, which we use as a reference to stage samples. 
Inferred age can be included as a covariate in analyses and increase their power to detect differential expression by including time-dependant effects. 
<!-- We also show multiple examples of how development impacts gene expression studies in multiple organisms. -->

<!-- `RAPToR` was developped to mediate the issue of developmental differences between samples by estimating the true age of transcriptomic samples from their gene expression profiles.  -->
<!-- While this is a major problem in the field of *C. elegans*, this issue occurs in various models where many factors can impact development speed (*e.g* *Drosophila*).  -->



# Why use `RAPToR` ?

Imprecise developmental staging is a known problem in transcriptomic analyses.
Unknown and unintended developmental variation among samples can obscure and confound the effect of variables of interest in a study.
For example, when large developmental timecourse datasets are produced, the samples are almost always re-ordered post-profiling.
This is because we are unable to experimentally synchronize samples to a satisfactory degree.

The methods used in the above scenario are usually a combination of a dimension-reduction analysis (*e.g* PCA, Diffusion Map) and a trajectory-finding method.
This can work when your experiment has hundreds of samples and/or happens to be a time series, but this is clearly not the general standard of current gene expression studies. 
The problem we are faced with is not limited to large scale experiments, why should we only address it in such scenarios ? 

`RAPToR` provides a way to precisely determine the real age of *single samples* from their expression profile.



# How does it work ?

The method works in a three-step process. 

 1. From a reference gene expression time series (several of which are included in associated data-packages), a near-continous, **high-temporal-resolution reference** is built.
 1. A **correlation profile** of your samples against this reference is computed from the gene expression information, the peak of which corresponds to the estimated age.
 1. A **bootstrap procedure** of the previous step on random subsets of genes is performed to give a confidence interval of the estimates.

<center>
![tool_overview](../inst/doc/tool_overview.png){width=60%}
</center>

# What type of data can be used ?

The `RAPToR` package allows you to estimate the developmental age of samples from their transcriptome.
This means that any data providing information on gene expression on a large scale is appropriate : RNA-seq counts (preferably RPKM), MicroArray/Chips...
Note that the references provided in the data-packages are $log(X+1)$ of expression values, applying this transformation to your data may lead to better performance of the tool.  

<div class="alert alert-danger">
  <strong>Warning :</strong><br/>
**The data must not be gene-centered**, as this destroys the relationship between gene levels within a sample.
</div>



# General structure of the tool

The main package (`RAPToR`) holds all the necessary functions to stage samples and build references.

We've aimed to provide a way to predict the age of samples easily and,
since our method requires a reference to stage samples against, we've built several from available data in the literature.
For R package standards, these are large datasets so the references are stored in separate "data-packages". 
To give an example, `wormRef` holds the *C. elegans* references.

You can see the available references of a data-package with the `list_refs()` function.

```{r list_refs}
list_refs("wormRef")
```

The data-packages currently available are listed on the [README of the github repo](https://github.com/LBCM/RAPToR).
You can build your own reference data packages following a few rules given in the [vignette on reference building](RAPToR-refbuilding.html).


# Usage example

In this part, we'll be showcasing usage of the tool on two *C. elegans* time series datasets from the literature. 

 1. A time series of larval development in 4 different strains published by @aeschimann2017lin41, hereafter called `ds1`.
 1. A high-resolution time series of late larval development published by @hendriks2014extensive, hereafter called `ds2`

Both datasets are available on GEO 
(
[GSE80157](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE80157), 
[GSE52861](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE52861)
).



## Loading the data
```{r load_pkg,  eval = F}
library(RAPToR)
```

As the code to create the `ds1` and `ds2` objects is quite lengthy and is not the object of this vignette, you can find it [at the end of the document](#load_ds1_ds2).




```{r load_ds, include=FALSE, eval=gen_figs}
load("../inst/extdata/ds1.RData")
load("../inst/extdata/ds2.RData")
```



Here is what our data looks like 
```{r head_ds1, eval = gen_figs}
ds1$g[1:5,1:4]
#>                let.7.n2853._18hr let.7.n2853._20hr let.7.n2853._22hr let.7.n2853._24hr
#> WBGene00000001         12.681443         11.267268         11.778583         11.581853
#> WBGene00000002          8.004784         11.242239          7.244600          5.837729
#> WBGene00000003          8.051166          6.108188          7.324310          8.981919
#> WBGene00000004         11.035511          9.075311          8.019064          8.234069
#> WBGene00000005          3.713297          7.289794          3.474924          1.972653

head(ds1$p, n = 5)
#>                        title geo_accession           organism_ch1       strain
#> GSM2113587 let.7.n2853._18hr    GSM2113587 Caenorhabditis elegans let-7(n2853)
#> GSM2113588 let.7.n2853._20hr    GSM2113588 Caenorhabditis elegans let-7(n2853)
#> GSM2113589 let.7.n2853._22hr    GSM2113589 Caenorhabditis elegans let-7(n2853)
#> GSM2113590 let.7.n2853._24hr    GSM2113590 Caenorhabditis elegans let-7(n2853)
#> GSM2113591 let.7.n2853._26hr    GSM2113591 Caenorhabditis elegans let-7(n2853)
#>            time in development:ch1 age
#> GSM2113587                18 hours  18
#> GSM2113588                20 hours  20
#> GSM2113589                22 hours  22
#> GSM2113590                24 hours  24
#> GSM2113591                26 hours  26
```

```{r head_ds2, eval = gen_figs}
ds2$g[1:5,1:5]
#>                contDevA_N2_21h contDevA_N2_22h contDevA_N2_23h contDevA_N2_24h contDevA_N2_25h
#> WBGene00000001       11.215486       10.561063        10.41683        9.703136       11.210885
#> WBGene00000002        5.954298        7.922576        11.32737       13.220574        9.781628
#> WBGene00000003       46.333242       29.539269        18.65796       12.425843       18.007778
#> WBGene00000004       13.939740       11.806423        10.60732       10.098591        9.553716
#> WBGene00000005        4.854516        7.360959        11.17349       13.243724       10.057926

head(ds2$p, n = 5)
#>                      title geo_accession time in development:ch1 age
#> GSM1277118 contDevA_N2_21h    GSM1277118                22 hours  22
#> GSM1277119 contDevA_N2_22h    GSM1277119                23 hours  23
#> GSM1277120 contDevA_N2_23h    GSM1277120                24 hours  24
#> GSM1277121 contDevA_N2_24h    GSM1277121                25 hours  25
#> GSM1277122 contDevA_N2_25h    GSM1277122                26 hours  26
```

We'll quantile-normalize and log the expression data.
```{r quantile_norm_log, eval = gen_figs}
ds1$g <- limma::normalizeBetweenArrays(ds1$g, method = "quantile")
ds1$g <- log(ds1$g + 1)

ds2$g <- limma::normalizeBetweenArrays(ds2$g, method = "quantile")
ds2$g <- log(ds2$g + 1)
```



The only other transformation the data may need is to convert its probe IDs or gene IDs to match the reference series'. 
For example, all the references included in the `wormRef` data-package use WormBase Gene IDs (*e.g.* `WBGene00016153`).

To help with this conversion, gene ID reference tables are included in the data-packages with common gene IDs (built directly from the `biomaRt`).



## Choosing a reference dataset

`RAPToR` estimates the developmental age of samples based on correlation with reference time series datasets. 
This means you have to select the proper reference to run your samples against.
By looking at reference list like above, or using the `plot_refs()` function, you can determine which reference is appropriate for your samples. 
If we haven't built your favorite organism's references yet, you can take a look at [how to build your own reference](#building-your-own-references) for a quick-start guide or the [reference-building vignette](RAPToR-refbuilding.html) for a more in-depth explanation.

The chart below shows the reference datasets available in the `wormRef` data package, along with landmark developmental stages. 

```{r plot_refs, fig.height=6, fig.width=9}
(plot_refs("wormRef"))
```



## Loading the reference

To bypass the limitations of available time series' reolution and provide precise estimates, `RAPToR` interpolates on the dynamics of gene expression of the reference series.
You can load a pre-built reference dataset with optimal parameters using the `prepare_refdata()` function.

For our example, the `Cel_larval` dataset would be appropriate since our samples are from mid-larval to early young adult in both datasets.
The `n.inter` parameter corresponds to the resolution of the interpolated reference. 
In the interest of lightening the computational load you can choose smaller values, but aim over the 500s for optimal results.


```{r prep_ref, eval=gen_figs}
r_larv <- prepare_refdata("Cel_larval", "wormRef", n.inter = 600)
```

Note that age estimates will be given in the time unit and scale of the chosen reference (here, hours post-hatching at 20$^\circ$C)


## Performing a simple age estimate

All we need to do now is run the `ae()` function.

```{r include=FALSE, eval=gen_figs}
set.seed(10)
```


```{r ae_ds1, eval=gen_figs, results='hold'}
ae_ds1 <- ae(samp = ds1$g,                         # input gene expression matrix
             refdata = r_larv$interpGE,            # reference gene expression matrix
             ref.time_series = r_larv$time.series) # reference time series
#> Bootstrap set size is 6239
#> Performing age estimation...
#> Bootstrapping...
#>  Building gene subsets...
#>  Computing correlations...
#>  Performing age estimation...
#> Computing summary statistics...
#> Warning in ae(samp = ds1$g, refdata = r_larv$interpGE, ref.time_series = r_larv$time.series): Some estimates come near the edges of the reference.
#> If possible, stage those on a different reference for confirmation.
#>                 nb.genes
#> refdata            18718
#> samp               19595
#> intersect.genes    18718
```

```{r ae_ds2, eval=gen_figs, results='hold'}
ae_ds2 <- ae(samp = ds2$g,                         # input gene expression matrix
             refdata = r_larv$interpGE,            # reference gene expression matrix
             ref.time_series = r_larv$time.series) # reference time series
#> Bootstrap set size is 6239
#> Performing age estimation...
#> Bootstrapping...
#>  Building gene subsets...
#>  Computing correlations...
#>  Performing age estimation...
#> Computing summary statistics...
#> Warning in ae(samp = ds2$g, refdata = r_larv$interpGE, ref.time_series = r_larv$time.series): Some estimates come near the edges of the reference.
#> If possible, stage those on a different reference for confirmation.
#>                 nb.genes
#> refdata            18718
#> samp               19595
#> intersect.genes    18718
```

Let's look at the results.


```{r plot_ae1_print, eval = F}
plot(ae_ds1, groups = ds1$p$strain, show.boot_estimates = T)
```

```{r plot_ae1, echo = F, fig.width=12, fig.height=7}
show_fig(expr = {
  plot(ae_ds1, groups = ds1$p$strain, show.boot_estimates = T)
}, fig.width=12, fig.height=7)
```


```{r plot_ae2_print, eval = F}
plot(ae_ds2, show.boot_estimates = T)
```
```{r plot_ae2, echo = F, fig.width=12, fig.height=4}
show_fig(expr = {
  plot(ae_ds2, show.boot_estimates = T)
}, fig.width=12, fig.height=4)
```


Since the staged samples were all grown at 25$^\circ$C, and the reference time is on 20$^\circ$C development, 
we can observe the well-known growth speed difference of 1.5 between *C. elegans* worms grown at these temperatures by fitting a simple linear model.


```{r lm_ds, eval = gen_figs}
lm_ds1 <- lm(ae_ds1$age.estimates[,1] ~ ds1$p$age)
summary(lm_ds1)
#> 
#> Call:
#> lm(formula = ae_ds1$age.estimates[, 1] ~ ds1$p$age)
#> 
#> Residuals:
#>      Min       1Q   Median       3Q      Max 
#> -2.01733 -0.77423  0.03879  0.57014  2.04296 
#> 
#> Coefficients:
#>             Estimate Std. Error t value Pr(>|t|)    
#> (Intercept) -4.17218    0.70058  -5.955 5.01e-07 ***
#> ds1$p$age    1.50745    0.02462  61.223  < 2e-16 ***
#> ---
#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
#> 
#> Residual standard error: 1.002 on 41 degrees of freedom
#> Multiple R-squared:  0.9892, Adjusted R-squared:  0.9889 
#> F-statistic:  3748 on 1 and 41 DF,  p-value: < 2.2e-16

lm_ds2 <- lm(ae_ds2$age.estimates[,1] ~ ds2$p$age)
summary(lm_ds2)
#> 
#> Call:
#> lm(formula = ae_ds2$age.estimates[, 1] ~ ds2$p$age)
#> 
#> Residuals:
#>     Min      1Q  Median      3Q     Max 
#> -0.7945 -0.2882 -0.1206  0.1447  0.8391 
#> 
#> Coefficients:
#>             Estimate Std. Error t value Pr(>|t|)    
#> (Intercept) -2.76603    0.76488  -3.616  0.00281 ** 
#> ds2$p$age    1.55868    0.02562  60.845  < 2e-16 ***
#> ---
#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
#> 
#> Residual standard error: 0.4724 on 14 degrees of freedom
#> Multiple R-squared:  0.9962, Adjusted R-squared:  0.996 
#> F-statistic:  3702 on 1 and 14 DF,  p-value: < 2.2e-16
```

```{r plot_compae, echo=F, fig.height=6, fig.width=12}
show_fig(expr = {

  par(mfrow = c(1,2))
  plot(ae_ds1$age.estimates[,1]~ds1$p$age, 
       xlab = "Chronological age (25C)", ylab = "Estimated age (20C)", 
       main = "Chronological vs Estimated ages for ds1", lwd = 2, col = factor(ds1$p$strain))
  invisible(sapply(levels(factor(ds1$p$strain)), function(l){
    s <- ds1$p$strain == l
    points(ae_ds1$age.estimates[s,1]~ds1$p$age[s], type = 'l', 
           lty = 2, col = which(l==levels(factor(ds1$p$strain))))
  }))
  
  abline(lm_ds1, lwd=2, col=2)
  legend("bottomright", legend = c("let-7", "lin-41", "let-7/lin-41", "N2", "lm_ds1"), 
         lwd=3, col=c(1:4, 2), bty='n', pch = c(1,1,1,1,NA), lty = c(rep(NA, 4), 1))
  
  plot(ae_ds2$age.estimates[,1]~ds2$p$age, 
       xlab = "Chronological age (25C)", ylab = "Estimated age (20C)", 
       main = "Chronological vs Estimated ages for ds2", lwd = 2)
  points(ae_ds2$age.estimates[,1]~ds2$p$age, type = 'l', lty = 2)
  abline(lm_ds2, lwd=2, col=2)
  
  legend("bottomright", legend = "lm_ds2", lwd=3, col=2, bty='n')
}, fig.height=6, fig.width=12)
```


## Understanding the output
The output of `ae()` is an `ae` object including various elements such as the age estimate and a confidence interval obtained through booststrapping (age estimate on random gene subsets).

<br>
General information can be accessed via the `summary()` function.
```{r summ_ae, eval = gen_figs}
summary(ae_ds2)
#> 
#> Span of samples : 23.339
#> Range of samples :  [ 31.701 , 55.04 ]
#> -----------------------------------------------------------
#>                 age.estimate     lb     ub
#> contDevA_N2_21h       31.701 31.587 31.815
#> contDevA_N2_22h       33.079 33.033 33.125
#> contDevA_N2_23h       34.273 34.227 34.319
#> contDevA_N2_24h       35.927 35.881 35.973
#> contDevA_N2_25h       37.673 37.491 37.855
#> contDevA_N2_26h       39.143 39.097 39.189
#> contDevA_N2_27h       41.716 41.534 41.898
#> contDevA_N2_28h       43.186 43.072 43.300
#> contDevA_N2_29h       44.105 43.923 44.287
#> contDevA_N2_30h       45.300 45.117 45.482
#> contDevA_N2_31h       46.770 46.588 46.952
#> contDevA_N2_32h       48.516 48.333 48.698
#> contDevA_N2_33h       49.435 49.252 49.617
#> contDevA_N2_34h       51.456 51.274 51.638
#> contDevA_N2_35h       54.121 54.075 54.167
#> contDevA_N2_36h       55.040 54.994 55.085
#> -----------------------------------------------------------
```



<br>
If you want to get the estimates and their confidence intervals, they are accessible through `$age.estimates`.
```{r show_ae, eval = gen_figs}
head(ae_ds2$age.estimates)
#>                 age.estimate       lb       ub cor.score
#> contDevA_N2_21h     31.70057 31.58651 31.81462 0.9296414
#> contDevA_N2_22h     33.07885 33.03291 33.12479 0.9297492
#> contDevA_N2_23h     34.27337 34.22742 34.31931 0.9331700
#> contDevA_N2_24h     35.92731 35.88137 35.97325 0.9312395
#> contDevA_N2_25h     37.67314 37.49096 37.85531 0.9315294
#> contDevA_N2_26h     39.14331 39.09736 39.18925 0.9345927
```

The table holds the following :

 - `age.estimate`, the global estimate for the sample (whole gene set).
 - `lb`, `ub`, the lower and upper bounds of the bootstrapped age estimates' confidence interval (Median Absolute Deviation).
 - `cor.score`, the correlation score of the global estimate.


## Plotting

Estimates and confidence intervals can be displayed in the form of a dotchart with the default `plot()` function (as we did above).

The `ae` object also holds the correlation scores of the samples against the entire reference series and their confidence intervals accross the bootstrap. 
You can also plot these correlation profiles with `plot_cor.ae()`

```{r plot_cor_print, eval = F}
par(mfrow=c(2,2))
plot_cor.ae(ae_ds2, subset = c(1,4,9,12))
```
```{r plot_cor, echo = F, fig.height=6, fig.width=12, fig.align='center'}
show_fig(expr = {
  par(mfrow=c(2,2))
  plot_cor.ae(ae_ds2, subset = c(1,4,9,12))
}, fig.height=6, fig.width=12)
```
The confidence interval of the estimates is represented with the red bars and the bootstrap correlation scores' 95% interval along the reference series are shown (as the black dotted lines). 
The sample's estimate is also given below the interval.

<br>
<br>





# Building your own references

Note that [there is a vignette entirely dedicated to this process](RAPToR-refbuilding.html), so this section is just a broad overview.

Interpolating on time series data is the basis for building the high-temporal-resolution references we need for `RAPToR`.
When using our pre-built references this is done through calling the `prepare_refdata()` function, but what's going on behind the scenes uses the functions described below. 

To build your reference, you will require a time series of gene expression data on your favourite organism.
The `ds1` example dataset we loaded earlier will be used to illustrate the process.

## The gene expression interpolation model interface

Gene expression interpolation models (GEIM), are built with the `ge_im()` function.
This function takes as input 3 key arguments : 

 - `X` : the gene expression matrix of your time series (genes as rows, samples as columns)
 - `p` : a dataframe of pheno data, samples as rows. This should include the age/time variable and any other covariates you want to include in the model (*e.g* batch, strain)
 - `formula` : the model formula. This should be a standard R formula, using terms found in `p`. **It should start with `X ~`**.

For example, using the `ds1` dataset we could build the following model.
```{r model_ds1, eval = gen_figs}
m_ds1 <- ge_im(X = ds1$g, p = ds1$p, formula = "X ~ s(age, bs = 'cr') + strain", nc = 24)
```


## About the models
The strategy we put forward for predicting on such a large scale of output variables, is to interpolate in a dimensionally reduced space. 
We propose to do this on Principal Components or Independant Components ( [Independant Component Analysis](https://en.wikipedia.org/wiki/Independent_component_analysis) ).

Both PCA and ICA perform the same type of linear transformation on the data (they just maximize a different criteria). We get the following :

$$
X_{(m\times n)} = G_{(m\times c)}S^{T}_{(n\times c)}
$$
with $X$, the matrix of $m$ genes by $n$ samples, $G$ the gene loadings ($m$ genes by $c$ components) and $S^T$ the sample loadings ($n$ samples by $c$ components). 
$S$ is what's usually looked at when performing a PCA (or ICA) on gene expression data, to look at the samples in the component space. 

@alter2000singular previously demonstrated that singular value decomposition of gene expression data can be taken as "eigengenes", giving a global picture of the dynamics of gene expression. 
We essentially use the same property for a GEIM.
We build a model on the columns of $S^T$ (eigengenes), predict in the component space, and reconstruct the gene expression data by a matrix product with the gene loadings. 

We've implemented 2 model types : Generalized Additive Models (GAMs, the default) and Generalized Linear Models (GLMs). 
GAMs rely on the `gam()` function of the [`mgcv`](https://cran.r-project.org/web/packages/mgcv/index.html) package, and GLMs on the `glm()` function of the `stats` core package. 
The specified model formula can make use of all the tools one can use with `gam()` or `glm()`, most notably the variety of polynomial or smoothing splines implemented through the `s()` function for GAMs.


Note that a single model formula is specified and applied to all the components, but the models are fitted independantly on the components.


## Finding the appropriate model and parameters
### Model type
The default GEIM is fitted using GAMs on PCA components, this is a robust choice when applying a smoothing spline to the data.
PCA and ICA interpolation yield near-identical results in most scenarios.

### Parameter estimation

The number of components to use for the interpolation is by default set to the number of samples.
However, we recommend to set a cutoff on explained variance of PCA components to select it. 
For example, on the `ds1` dataset, we set the threshold at $99.9\%$ :

```{r pca_ds1, eval = gen_figs}
pca_ds1 <- stats::prcomp(ds1$g, rank = 25)
nc <- sum(summary(pca_ds1)$importance[3,] < .999) + 1
nc
#> [1] 24v
```


Choosing from different splines (and/or parameters) can be done with cross-validation (CV) through the use of the `ge_imCV()` function. 
The function inputs the `X`, `p` and a `formula_list` to test. 
Other parameters on the CV itself can also be given (*e.g.* training set size).


Below is an example of usage to choose between 4 available smooth terms on the `ds1` GEIM.
```{r include = F, eval = gen_figs}
set.seed(10)
```

```{r cv_ds1, eval = gen_figs, results='markup'}
smooth_methods <- c("tp", "ts", "cr", "ps")
flist <- as.list(paste0("X ~ s(age, bs = \'", smooth_methods, "\') + strain"))
flist
#> [[1]]
#> [1] "X ~ s(age, bs = 'tp') + strain"
#> 
#> [[2]]
#> [1] "X ~ s(age, bs = 'ts') + strain"
#> 
#> [[3]]
#> [1] "X ~ s(age, bs = 'cr') + strain"
#> 
#> [[4]]
#> [1] "X ~ s(age, bs = 'ps') + strain"

cv_ds1 <- ge_imCV(X = scale(ds1$g), p = ds1$p, formula_list = flist,
                  cv.n = 20, nc = nc, nb.cores = 3)
#> CV on 4 models. cv.n = 20 | cv.s = 0.8
#> 
#> ...Building training sets
#> ...Setting up cluster
#> ...Running CV
#> ...Cleanup and formatting
```

```{r plot_cv_ds1_print, eval = F}
plot(cv_ds1, names = paste0("bs = ", smooth_methods), outline = F,
     swarmargs = list(cex = .8))
```
```{r plot_cv_ds1, echo = F, fig.width=12, fig.height=8, fig.align='center'}
show_fig(expr = {
  plot(cv_ds1, names = paste0("bs = ", smooth_methods), outline = F,
       swarmargs = list(cex = .8))
  
}, fig.width=12, fig.height=8)
```

`ge_imCV()` computes various indices of model performance :
the average Correlation Coefficient (`aCC`), the average Relative Error (`aRE`), Mean Squared Error (`MSE`) and average Root MSE (`aRMSE`). 
These indices all compare model predictions and the true data. 
The `ge_imCV()` function computes them on the validation set (CV Error) *and* on the training set (Model PerFormance).

From the plots above, the cubic regression spline (`cr`) seems to be the best-performing choice. 


## Predicting from the model

The `geim` object returned by `ge_im()` has its predict method which can be used like for any model.
You can also specify if you want the predictions as components or as the full gene expression matrix.

On our `ds1` example :
```{r pred_ds1, eval = gen_figs}
# setup new data
n.inter <- 100
ndat <- data.frame(age = seq(min(ds1$p$age), max(ds1$p$age),  l = n.inter), 
                   strain = rep("N2", n.inter))

# predict
pred_ds1_comp <- predict(m_ds1, ndat, as.c = TRUE)
pred_ds1_ge <- predict(m_ds1, ndat)
```


## Checking/Validating the interpolation

We have built our model, now we can have a look at the interpolation results.
To do this, one can do two things : 

 - Check the model predictions against components (plots)
 - Stage the samples on their own interpolated data, or better (if possible) stage another time series on your reference for external validation.

We can do both with our example, the `ds2` dataset can be used for external validation.

```{r plot_pca_ds1, echo = F, fig.width=12, fig.height=6}
show_fig(expr = {
  
  par(mfrow = c(2,4))
  invisible(sapply(seq_len(8), function(i){
    plot(ds1$p$age, pca_ds1$rotation[,i], lwd = 2, col = ds1$p$strain,
         xlab = "age", ylab = "PC", main = paste0("PC", i))
    sapply(seq_along(levels(ds1$p$strain)), function(l){
      s <- which(ds1$p$strain == levels(ds1$p$strain)[l])
      points(ds1$p$age[s], pca_ds1$rotation[s,i], col = l, 
             type = 'l', lty = 2)
    })
    points(ndat$age, pred_ds1_comp[, i], col = "royalblue", type = 'l', lwd = 2)
    if(i == 1)
      legend("topleft", bty = 'n', legend = c("let-7", "lin-41", "let-7/lin-41", "N2", "pred"),
             pch = c(rep(1, 4), NA), lty = c(rep(NA, 4), 1), col = c(1:4, "royalblue"), lwd = 3)
  }))
}, fig.width=12, fig.height=6)
```

```{r ae_ds1_test_print, eval = F}
# make a 'reference object' 
r_ds1 <- list(interpGE = pred_ds1_ge, time.series = ndat$age)

ae_test_ds1 <- ae(ds1$g, r_ds1$interpGE, r_ds1$time.series)
ae_test_ds2 <- ae(ds2$g, r_ds1$interpGE, r_ds1$time.series)
```

```{r ae_ds1_test, include = F, eval = gen_figs}
# make a 'reference object' 
r_ds1 <- list(interpGE = pred_ds1_ge, time.series = ndat$age)

ae_test_ds1 <- ae(ds1$g, r_ds1$interpGE, r_ds1$time.series, bootstrap.n = 1)
ae_test_ds2 <- ae(ds2$g, r_ds1$interpGE, r_ds1$time.series, bootstrap.n = 1)
```


```{r plot_comp_aeref, echo=F, fig.height=6, fig.width=12}
show_fig(expr = {
  par(mfrow = c(1,2))
  rg <- range(c(ae_test_ds1$age.estimates[,1], ds1$p$age))
  plot(ae_test_ds1$age.estimates[,1]~ds1$p$age, 
       xlab = "Chronological age", ylab = "Estimated age (ds1)", 
       xlim = rg, ylim = rg,
       main = "Chron. vs Estimated ages for ds1 (on ds1 reference)", lwd = 2, col = factor(ds1$p$strain))
  invisible(sapply(levels(factor(ds1$p$strain)), function(l){
    s <- ds1$p$strain == l
    points(ae_test_ds1$age.estimates[s,1]~ds1$p$age[s], type = 'l', 
           lty = 2, col = which(l==levels(factor(ds1$p$strain))))
  }))
  
  abline(a = 0, b = 1, lty = 3, lwd = 2)
  legend("bottomright", legend = c("let-7", "lin-41", "let-7/lin-41", "N2", "x = y"), 
         lwd=3, col=c(1:4, 1), bty='n', pch = c(1,1,1,1,NA), lty = c(rep(NA, 4), 3))
  
  rg <- range(c(ae_test_ds2$age.estimates[,1], ds2$p$age))
  plot(ae_test_ds2$age.estimates[,1]~ds2$p$age, 
       xlab = "Chronological age", ylab = "Estimated age (ds1)", 
       xlim = rg, ylim = rg,
       main = "Chron. vs Estimated ages for ds2 (on ds1 reference)", lwd = 2)
  points(ae_test_ds2$age.estimates[,1] ~ ds2$p$age, type = 'l', lty = 2)
  abline(a = 0, b = 1, lty = 3, lwd = 2)
  
  legend("bottomright", legend = "x = y", lwd=3, col=1, lty = 3, bty='n')
}, fig.height=6, fig.width=12)
```


<!-- # Advanced usage -->

<!-- ## If the bootstrap estimates 'jump around' -->

<!-- In some cases, two different developmental time points of the reference can both be very closely correlated with a sample. -->
<!-- This has the consequence that, with some random gene subsets, the bootstrap estimates will 'jump' between them and the confidence interval will be quite large. -->

<!-- This can be due to different problems : -->

<!--  - If the sample is bulk, there can be worms of an unexpected developmental stage contaminating it -->
<!--  - The overlapping gene set between the sample and the reference may be missing key gene groups necessary to distinguish between larval states ; unlikely, unless  -->
<!--  - The overlapping gene set is very small (less than a few thousand), which necessarily means that -->
<!--  - The boostrap gene subset size is too small -->
<!--  - Random gene subset selection can also in rare cases make the difference between larval stages ambiguous -->

<!-- We can simulate the "small bootstrap set size" by messing with the `bootstrap.set_size` parameter. -->
<!-- ```{r boot_jump, cache=quick_build} -->
<!-- set.seed(5) # for reproducible results (get the same random gene subsets each time) -->

<!-- ae_hend_boot <- estimate.worm_age(samp = geno.hendriks[, 4:6], # select a few samples  -->
<!--                                   refdata = ref$interpol.gene_expr, -->
<!--                                   ref.time_series = ref$time.series, -->
<!--                                   bootstrap.set_size = 300, # make the bt subset size very small -->
<!--                                   bootstrap.n = 50) # do more bt steps to be sure to get the issue -->
<!-- ``` -->

<!-- <!-- The samples with this problem are detected through the `IC.imbalance` criterion mentioned above (when >5), and marked in the summary by an asterisk. --> 
<!-- <!-- ```{r sum_hen_boot} --> 
<!-- <!-- summary(ae_hend_boot) --> 
<!-- <!-- ``` --> 
<!-- We can show the bootstrap estimates as swarms on the `ae` plot, allowing us to see their distribution along the reference time. -->
<!-- ```{r pl_hen_boot, fig.height=3, fig.width=8} -->
<!-- plot(ae_hend_boot, show.boot_estimates = TRUE, col.b = 'firebrick', xlim=c(20,40)) -->
<!-- ``` -->

<!-- You'll notice that most of our bootstrap estimates are still around the global estimate, and that a few have gone astray 10 hours back (*ie* on the previous molt/larval state, in our case). -->
<!-- If you see this, increasing the bootstrap gene subset size should solve the issue (default is $n/3$, with $n$ the number of overlapping genes between sample and reference). -->





<br>

<!-- If you notice the bootstrap estimates are spread half and half, even with a large number of bootstrap steps (>=100), you may want to consider using a prior for these particular samples.  -->
<!-- Be warned that using priors has a significant impact on the estimate. -->
<!-- Also, in this scenario, it is possible your data may be a mix of two distinct larval states. -->



# Using a prior

In some cases, it may be appropriate to use a prior, helping with the estimate.
In the `ae()` function, priors work by giving the parameters for gaussian distributions (for each sample). The correlation peaks are then ranked according to the prior's density at their respective time.
The correlation profile is unaffected by the prior, only the choice of the correlation peak is.

**This implies that with a prior which is completely off, the estimate may also be wrong ; use with care.**

The priors are given *in the reference series' time scale*, so beware of growth speed difference with temperature or different time origins (fertilization, egg-laying, hatching...). 
For example, the `ds2` *C. elegans* data we used previously is grown at 25$^\circ$C, in contrast with the references' time for 20$^\circ$C development. 

Due to these possible differences and the bias introduced by the prior, we recommend to carefully plan its use. 
Performing a first run without priors will give a general idea of the difference between the chronological and developmental age of your samples.

Once the priors are determined, you will need to set the standard deviation of the gaussian centered on the sample with the `prior.params` argument. 
This parameter will also indirectly change the weight of the prior over the correlation score for estimate selection.

On our `ds2` example, we can use ajusted known chronological ages for 20$^\circ$C.
```{r hend_prior, eval = gen_figs}
priors <- ds2$p$age * 1.6 - 5 # rough approximation based on our previous lm

ae_ds2_prior <- ae(samp = ds2$g,
                   refdata = r_larv$interpGE,
                   ref.time_series = r_larv$time.series,
                   prior = priors,
                   prior.params = 10)
#>                 nb.genes
#> refdata            18718
#> samp               19595
#> intersect.genes    18718
#> Bootstrap set size is 6239
#> Performing age estimation...
#> Bootstrapping...
#>  Building gene subsets...
#>  Computing correlations...
#>  Performing age estimation...
#> Computing summary statistics...
#> Warning in ae(samp = ds2$g, refdata = r_larv$interpGE, ref.time_series = r_larv$time.series, : Some estimates come near the edges of the reference.
#> If possible, stage those on a different reference for confirmation.
```


```{r plot_ae_prior_print, eval=F}
plot(ae_ds2_prior, main="Age estimates with priors on ds2", show.boot_estimates = T,
     show.prior = T, col.p = 'red', l.pos = 'bottomright')

all(ae_ds2_prior$age.estimates[,1]==ae_ds2$age.estimates[,1])
```
```{r plot_ae_prior, echo = F, fig.height=5, fig.width=9, fig.align='center'}
show_fig(expr = {
  
  plot(ae_ds2_prior, main="Age estimates with priors on ds2", show.boot_estimates = T,
       show.prior = T, col.p = 'red', l.pos = 'bottomright')
  
  all(ae_ds2_prior$age.estimates[,1]==ae_ds2$age.estimates[,1])
}, fig.height=5, fig.width=9)
```



As you can see, here the estimates are the same as without the prior. 


<a name="load_ds1_ds2"></a>

# Loading `ds1` and `ds2`


```{r load_namespaces, include = F, eval = F}
requireNamespace("wormRef", quietly = T)
requireNamespace("utils", quietly = T)
requireNamespace("Biobase", quietly = T)
requireNamespace("GEOquery", quietly = T)
```

```{r raw2rpkm_func, eval = F}
raw2rpkm <- function(X, gene.length, id.col = 1, l.col='length'){
  # Compute RPKM from raw counts
  if(!all(rownames(X)%in%gene.length[, id.col])){
    stop("Some genes are missing length info !")
  }
  res <- sapply(colnames(X), function(samp){
    pm <- sum(X[,samp])/1e6
    rpkm <- (X[,samp]/pm)/(gene.length[match(rownames(X), gene.length[, id.col]), l.col]/1000)
  })
  rownames(res) <- rownames(X)
  return(res)
}
```

```{r load_ds1_c, eval = F}
geo_ds1 <- "GSE80157"

g_url_ds1 <- GEOquery::getGEOSuppFiles(geo_ds1, makeDirectory = FALSE, fetch_files = FALSE)
g_file_ds1 <- "../inst/extdata/ds1.txt.gz"
utils::download.file(url = as.character(g_url_ds1$url[2]), destfile = g_file_ds1)

X_ds1 <- read.table(gzfile(g_file_ds1), h=T, sep = '\t', stringsAsFactors = F, row.names = 1)

# convert to rpkm & wb_id
X_ds1 <- RAPToR::format_ids(X_ds1, wormRef::Cel_genes, from = "wb_id", to = "wb_id")
X_ds1 <- raw2rpkm(X = X_ds1, gene.length = wormRef::Cel_genes, id.col = "wb_id", l.col = "transcript_length")





# pheno data
P_ds1 <- Biobase::pData(GEOquery::getGEO(geo_ds1, getGPL = F)[[1]])
P_ds1[,10:34] <- NULL
P_ds1[, 3:8] <- NULL

colnames(P_ds1)[4] <- "strain"
P_ds1$strain <- factor(P_ds1$strain)
P_ds1$title <- gsub('[-\\(\\);]', '.', P_ds1$title)

colnames(X_ds1) <- gsub('RNASeq_riboM_', '', colnames(X_ds1), fixed = T)
P_ds1$title <- gsub('RNASeq_riboM_', '', P_ds1$title, fixed = T)

# get age 
P_ds1$age <- as.numeric(sub('(\\d+)\\shours', '\\1', P_ds1$`time in development:ch1`))


X_ds1 <- X_ds1[, P_ds1$title]

ds1 <- list(g = X_ds1, p = P_ds1)
save(ds1, file = "../inst/extdata/ds1.RData", compress = "xz")

# cleanup
file.remove(g_file_ds1)
rm(geo_ds1, g_url_ds1, g_file_ds1, X_ds1, P_ds1)
```

```{r load_ds2_c, eval = F}
geo_ds2 <- "GSE52861"

g_url_ds2 <- GEOquery::getGEOSuppFiles(geo_ds2, makeDirectory = FALSE, fetch_files = FALSE)
g_file_ds2 <- "../inst/extdata/ds2.txt.gz"
utils::download.file(url = as.character(g_url_ds2$url[2]), destfile = g_file_ds2)

X_ds2 <- read.table(gzfile(g_file_ds2), h=T, sep = '\t', stringsAsFactors = F, row.names = 1)

# convert to rpkm & wb_id
X_ds2 <- RAPToR::format_ids(X_ds2, wormRef::Cel_genes, from = "wb_id", to = "wb_id")
X_ds2 <- raw2rpkm(X = X_ds2, gene.length = wormRef::Cel_genes, id.col = "wb_id", l.col = "transcript_length")


# pheno data
P_ds2 <- Biobase::pData(GEOquery::getGEO(geo_ds2, getGPL = F)[[1]])

# filter relevant fields/samples
P_ds2 <- P_ds2[(P_ds2$`strain:ch1` == 'N2') & (P_ds2$`growth protocol:ch1` == 'Continuous'), ]
P_ds2 <- P_ds2[, c("title", "geo_accession", "time in development:ch1")]

# get age 
P_ds2$age <- as.numeric(sub('(\\d+)\\shours', '\\1', P_ds2$`time in development:ch1`))


# formatting
P_ds2$title <- gsub('RNASeq_polyA_', '', 
                  gsub('hr', 'h', 
                       gsub('-', '.', fixed = T, as.character(P_ds2$title))))
colnames(X_ds2) <- gsub('RNASeq_polyA_','', colnames(X_ds2))
X_ds2 <- X_ds2[, P_ds2$title]

ds2 <- list(g = X_ds2, p = P_ds2)
save(ds2, file = "../inst/extdata/ds2.RData", compress = "xz")

# cleanup
file.remove(g_file_ds2)
rm(geo_ds2, g_url_ds2, g_file_ds2, X_ds2, P_ds2)
```


<hr>

# References
