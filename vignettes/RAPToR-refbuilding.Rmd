---
title: "`RAPToR` - Building References"
output: 
  rmarkdown::html_document :
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{RAPToR-refbuilding}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
author: Romain Bulteau
date: "`r format(Sys.Date(), '%B %Y')`"
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  out.width = '100%'
)
options(width=100)
quick_build <- T # wether to cache heavy-computation chunks 

library(RAPToR)
library(RColorBrewer)

requireNamespace("limma", quietly = T)
requireNamespace("stats")
```

```{r load_ds, include=FALSE}
load("../inst/extdata/ds1.RData")
load("../inst/extdata/ds2.RData")
```

```{r transp_function, echo=F}
transp <- function(col, a=.5){
  colr <- col2rgb(col)
  return(rgb(colr[1,], colr[2,], colr[3,], a*255, maxColorValue = 255))
}
```


# Preamble

This vignette is specifically focused on building references needed to stage samples with `RAPToR`.
For a more general use of the package, [see the `"RAPToR"` vignette](RAPToR.html).


Building references is one of the key aspects of `RAPToR`. 
An appropriate reference is needed to stage samples, and since they are re-usable we believe they are worth the trouble to set up.

Throughout this vignette, you will see the general workflow of building a reference from the selection of an appropriate dataset, to choosing and validating a model for interpolation. 
In the midst of the explanations, examples will be given using the same `ds1` and `ds2` datasets as in the general usage vignette ( [you can check out how these were built at the end of that vignette](RAPToR.html#load_ds1_ds2) ).

Finally, a few more examples of reference building on different datasets will be included at the end of this document.

I hope this material will be sufficient for your reference-building needs. 


# The data

## Selecting / Preparing a dataset

Without a transcriptomic timecourse dataset spanning the developmental stages of your samples' organism, I'm afraid there's not much we can do for you ! 
Thankfully, these time-series experiments are (increasingly) numerous in the literature and most model organisms will have some kind of dataset we can use. 
You may also have your own time-series data on hand.

### Databases
There are a few databases you can download datasets from. 
The most well-known the [Gene Expression Omnibus (GEO)](https://www.ncbi.nlm.nih.gov/geo/) and the [Array Express](https://www.ebi.ac.uk/arrayexpress/).

Both of these databases have APIs to get their data from R (*e.g* [the `GEOquery` package](https://bioconductor.org/packages/release/bioc/html/GEOquery.html), as shown in the example dataset loading scripts).

### What to look out for
Several points of the experimental design should be kept in mind when selecting a dataset for a reference.

   * ***Are there replicates ?*** If so, good. This means you can confirm the dynamics in your data are not noise. I would choose a sparser time-course with replicates over a high-resolution experiment with one batch to build a reference.
   * ***Is the timepoint sampling even ?*** Transcriptomic profiling is expensive. Time courses experiments usually account for dynamic ranges of development (*i.e*, early or fast-changing stages are more sampled). For our purpose, we ideally want even sampling.  However, if a dataset's sampling respects dynamic ranges, you can still use it for reference building with a trick using ranks.
   * ***What's the developmental range ?*** The bigger, the better ! (Though as long as the samples to stage fit within, this is good).
   * ***Is the profiling done on whole-organism or specific parts ?*** You should aim for whole-organism profiling. Even if you have to stage tissue-specific samples, a good quality reference should still allow you to get accurate estimates, perhaps restraining the geneset used for staging.
   * ***What's the profiling technology*** RNA-seq is much, *much* cleaner than MicroArray data. Sometimes, you just have to make do.
   
   
### ID formatting

One of the plagues of bioinformatics is the large and fast-changing set of IDs for genes, transcripts, etc.
When you build a reference, you should always convert it to IDs that are **conventional and stable**.
We like to use the organism-specific IDs (*e.g*, Wormbase for *C. elegans* : `WBGene00016153`, Flybase for *Drosophila* : `FBgn0010583`).

The [ensembl biomart](https://www.ensembl.org/info/data/biomart/index.html) or its associated R package [`biomaRt`](https://bioconductor.org/packages/release/bioc/html/biomaRt.html) are a very useful ressource to get gene, transcript or probe ID lists for conversion.

Below is a code snippet with an example getting gene IDs for drosophila with `biomaRt`.

```{r biomart_example, eval = F}
requireNamespace("biomaRt", quietly = TRUE)

# setup connection to ensembl
mart <- biomaRt::useMart("ensembl", dataset = "dmelanogaster_gene_ensembl")

# get list of attributes
droso_genes <- biomaRt::getBM(attributes = c("ensembl_gene_id", 
                                             "ensembl_transcript_id",
                                             "external_gene_name",
                                             "flybase_gene_id"),
                              mart = mart)

head(droso_genes)
#>   ensembl_gene_id ensembl_transcript_id external_gene_name flybase_gene_id
#> 1     FBgn0053882           FBtr0091886      His2B:CG33882     FBgn0053882
#> 2     FBgn0035648           FBtr0113148            CG13288     FBgn0035648
#> 3     FBgn0035648           FBtr0331563            CG13288     FBgn0035648
#> 4     FBgn0032726           FBtr0342927            CG10621     FBgn0032726
#> 5     FBgn0032726           FBtr0342926            CG10621     FBgn0032726
#> 6     FBgn0032726           FBtr0081191            CG10621     FBgn0032726
```

When multiple probe or transcript IDs match a single gene ID, we usually go for mean-aggregation of expression values. 
This is taken care of with the `format_ids()` function.


### Normalize and log expression

It's common practice to normalize expression datasets (*e.g.* to account for technical bias).
You may deal with many different profiling technologies when building references, and may join multiple datasets together for a reference.

To stay as consistent as possible, we apply quantile-normalization on our datasets regardless of its source.
For this, we use the `normalizeBetweenArrays()` function of the [`limma`](https://bioconductor.org/packages/release/bioc/html/limma.html) package.

We also apply a $log(X + 1)$.

```{r quantile_norm_log}
ds1$g <- limma::normalizeBetweenArrays(ds1$g, method = "quantile")
ds1$g <- log(ds1$g + 1)

ds2$g <- limma::normalizeBetweenArrays(ds2$g, method = "quantile")
ds2$g <- log(ds2$g + 1)
```


## Observing the data

It's usually a good practice to take a look at what's inside your data before doing anything else to it.

```{r obs_head, results='markup'}
ds1$g[1:5, 1:5]

head(ds1$p, n = 5)
```


### Correlation
With our time series data, we can look at correlation heatmaps or boxplots of the samples to catch potential ouliers and observe the clear correlation between samples of similar development.

```{r obs_data_corr}
cor_ds1 <- cor(ds1$g, method = "spearman")
```

<div style = "display:block">
<div style="width:40%; float:left">
```{r hm_cor, echo = F, fig.height=5, fig.width=5}
ord <- order(ds1$p$age)
heatmap(cor_ds1[ord, ord], Colv = NA, Rowv = NA, scale = "none", keep.dendro = F, margins = c(1,1),
        RowSideColors = transp(as.numeric(ds1$p$strain[ord])), labRow = "", labCol = "")
par(xpd = T)
mtext(text = unique(ds1$p$age), side = 1, line = 4, at = seq(-.1,1.05, l = 11))

```
</div>
<div style="width:59%; float:right">
```{r bxplot_cor, echo = F, fig.show='hold', warning=FALSE}
# p <- par()
# layout(matrix(1:2, ncol = 2), widths = c(.8,.2))
boxplot(cor_ds1 ~ interaction(ds1$p$strain, ds1$p$age), col = transp(1:4), xaxt = "n", ylab = "Spearman correlation",
        xlab = "age", at = seq(1,44, l = 55)[c(T,T,T,T,F)])
axis(side = 1, at = seq(2,42, l = 11), labels = unique(ds1$p$age))
# par(mar = rep(1,4))
# plot.new()
legend(23,.86, fill = transp(1:4), legend = c("let-7", "lin-41", "let-7/lin-41", "N2"),
       bty = "n")
```
</div>
</div>
<div style="clear: both;"></div>

### Plotting components
You can also plot components (PCA or ICA) with respect to time, to get an idea of the dynamics.

```{r obs_prcomp}
pca_ds1 <- stats::prcomp(ds1$g, rank = 25)
```

```{r plot_pcads1, echo = F, fig.height=6, fig.width=12}
par(mfrow = c(2,4))
invisible(sapply(seq_len(8), function(i){
  plot(ds1$p$age, pca_ds1$rotation[,i], lwd = 2, col = ds1$p$strain,
       xlab = "age", ylab = "PC", main = paste0("PC", i))
  sapply(seq_along(levels(ds1$p$strain)), function(l){
    s <- which(ds1$p$strain == levels(ds1$p$strain)[l])
    points(ds1$p$age[s], pca_ds1$rotation[s,i], col = l, 
           type = 'l', lty = 2)
  })
  # points(ndat$age, pred_ds1_comp[, i], col = "royalblue", type = 'l', lwd = 2)
  if(i == 1)
    legend("topleft", bty = 'n', legend = c("let-7", "lin-41", "let-7/lin-41", "N2"),
           pch = c(rep(1, 4)), lty = c(rep(NA, 4)), col = c(1:4), lwd = 3)
}))
```

In this data, we see that between different strains, we get very consistent dynamics. 
Also, PC3 and PC4 capture an oscillatory dynamic characteristic of the molting processes of *C. elegans* larval development.


### Plotting random genes
Another approach can be to look at a few random genes. You get a first hand look at the noise in your data.

```{r plot_rdgn, echo = F, fig.height=3, fig.width=12}
set.seed(3)
gtp <- sample(nrow(ds1$g), size = 4)
par(mfrow = c(1,4))
invisible(sapply(gtp, function(i){
  plot(ds1$p$age, ds1$g[i,], lwd = 2, col = ds1$p$strain,
       xlab = "age", ylab = "GExpr", main = rownames(ds1$g)[i])
  sapply(seq_along(levels(ds1$p$strain)), function(l){
    s <- which(ds1$p$strain == levels(ds1$p$strain)[l])
    points(ds1$p$age[s], ds1$g[i,s], col = l, 
           type = 'l', lty = 2)
  })
  # points(ndat$age, pred_ds1_comp[, i], col = "royalblue", type = 'l', lwd = 2)
  if(i == 1)
    legend("topleft", bty = 'n', legend = c("let-7", "lin-41", "let-7/lin-41", "N2"),
           pch = c(rep(1, 4)), lty = c(rep(NA, 4)), col = c(1:4), lwd = 3)
}))
```


<br>
<br>
<br>

# The gene expression interpolation model

To increase the resolution of our time series, we are faced with a very unbalanced regression problem.
We essentially want to predict tens of thousands of dependent variables (genes) with our few independent variables (time, batch, ...).

We refer to the gene expression interpolation model as GEIM in the following text. 


## About the model

The principal strategy we put forward for predicting on such a large scale of output variables, is to interpolate in a dimensionally reduced space. 
We propose to do this on Principal Components or Independant Components ( [Independant Component Analysis](https://en.wikipedia.org/wiki/Independent_component_analysis) ).

Both PCA and ICA perform the same type of linear transformation on the data, they just maximize a different criteria. 
PCA maximizes the variance of each component and ICA their independance. We get the following :

$$
X_{(m\times n)} = G_{(m\times c)}S^{T}_{(n\times c)}
$$
with $X$, the matrix of $m$ genes by $n$ samples, $G$ the gene loadings ($m$ genes by $c$ components) and $S^T$ the sample loadings ($n$ samples by $c$ components). 
$S$ is what's usually looked at when performing a PCA (or ICA) on gene expression data, to look at the samples in the component space. It's what we plotted in the section on observing data, for instance. 

@alter2000singular previously demonstrated that singular value decomposition of gene expression data can be taken as "eigengenes", giving a global picture of the dynamics of gene expression. 
We essentially use the same property for a GEIM.
We build a model on the columns of $S^T$ (eigengenes), predict in the component space, and reconstruct the gene expression data by a matrix product with the gene loadings. 

We've implemented 2 model types : Generalized Additive Models (GAMs, the default) and Generalized Linear Models (GLMs). 
GAMs rely on the `gam()` function of the [`mgcv`](https://cran.r-project.org/web/packages/mgcv/index.html) package, and GLMs on the `glm()` function of the `stats` core package. 

As you'll see in the next section, a standard R formula will be specifed to the model.
This formula can make use of all the tools one can use with `gam()` or `glm()`, most notably the variety of polynomial or smoothing splines implemented through the `s()` function for GAMs. 
With GLMs, you can also use splines from the `splines` core package, such as `ns()` for natural cubic splines.


## The GEIM interface

GEIMs, are built with the `ge_im()` function, which outputs a `geim` object.
This function takes as input 3 key arguments : 

 - `X` : the gene expression matrix of your time series (genes as rows, samples as columns)
 - `p` : a dataframe of pheno data, samples as rows. This should include the age/time variable and any other covariates you want to include in the model (*e.g* batch, strain)
 - `formula` : the model formula. This should be a standard R formula, using terms found in `p`. **It should start with `X ~`**.
 
Another important argument is the number of components used for the interpolation, `nc`.

For example, using the `ds1` dataset we could build the following model.
```{r model_ds1}
m_ds1 <- ge_im(X = ds1$g, p = ds1$p, formula = "X ~ s(age, bs = 'cr') + strain", nc = 24)
```

Note that a single model formula is specified and applied to all the components, but the models are fitted independantly on each component.

Feel free to have a look at the documentation of the function for additionnal parameters `?ge_im()`.

To get model predictions, you simply use the `predict()` function, like for any standard R model.


## Finding the appropriate model and parameters
### Model type
There are 5 types of GEIM you can fit with the `ge_im()` function.

* A GAM on PCA components (`method = "gam", dim_red = "pca"`) (default)
* A GLM on PCA components (`method = "glm", dim_red = "pca"`)
* A GAM on ICA components (`method = "gam", dim_red = "ica"`)
* A GLM on ICA components (`method = "glm", dim_red = "ica"`)
* A gene-by-gene linear model directly on the gene expression matrix (`method = "limma"`)

The default option is a robust choice when applying a smoothing spline to the data.

Using PCA or ICA components yields near-identical results in most scenarios. 
ICA tends to outperform PCA when the data is very noisy. 
This is by design since ICA essentially performs signal extraction.
It is however slower, especially if `nc` is large.

The last option (`"limma"`) corresponds to a solution that makes no effort to reduce the dimensionality of the problem (the `dim_red` and `nc` arguments are ignored). 
As a result, there is no information loss or bias introduced by dimension reduction. 
This approach is however very sensitive to noise.
The model is fit with the `lmFit()` function of the `limma` package (hence the name).

### Model performance
One can use a number of criteria to evaluate model performance. 
We provide the `mperf()` function to compute various indices by inputing the data and the model predictions. 

In the formulas below, $X$ corresponds to the input gene expression matrix ($m$ genes as rows, $n$ samples as columns), $\hat{X}$ to the model predictions. $x_i$ corresponds to row $i$ of matrix $X$ and $x_i^{(j)}$ to sample $j$ of that row. 
This notation is derived from the general regression problem, where $X^T$ corresponds to the set of $m$ dependant variable to predict.

 - `aCC` : average Correlation Coefficient.
 
$$ 
 aCC = \frac{1}{m}\sum^{m}_{i=1}{CC} = \frac{1}{m}\sum^{m}_{i=1}{\cfrac{\sum^{n}_{j=1}{(x_i^{(j)}-\bar{x}_i)(\hat{x}_i^{(j)}-\bar{\hat{x}}_i)}}{\sqrt{\sum^{n}_{j=1}{(x_i^{(j)}-\bar{x}_i)^2(\hat{x}_i^{(j)}-\bar{\hat{x}}_i)^2}}}}
$$

 - `aRE` : average Relative Error. 
 
$$ 
a\delta = \frac{1}{m}\sum^{m}_{i=1}{\delta} = \frac{1}{m} \sum^{m}_{i=1} \frac{1}{n} \sum^{n}_{j=1} \cfrac{| x_i^{(j)} - \hat{x}_i^{(j)} | }{x_i^{(j)}}
$$

 - `MSE` : Mean Squared Error. 

$$ 
MSE = \frac{1}{m} \sum^{m}_{i=1} \frac{1}{n} \sum^{n}_{j=1} (x_i^{(j)} - \hat{x}_i^{(j)} )^2
$$

 - `aRMSE` : average Root MSE.
 
$$ 
aRMSE = \frac{1}{m}\sum^{m}_{i=1}{RMSE} = \frac{1}{m} \sum^{m}_{i=1} \sqrt{\cfrac{\sum^{n}_{j=1} (x_i^{(j)} - \hat{x}_i^{(j)} )^2}{n}}
$$

Note that these indices are computed and averaged *with respect to variables, not observations*. 
You can either get the overall value or the

### Number of components 
The number of components to use for the interpolation is by default set to the number of samples.
However, we recommend to set a cutoff on explained variance of PCA components to select it. 
You can do this (on PCA explained variance) even if you choose to use ICA for interpolation.

For example, on the `ds1` dataset, we set the threshold at $99.9\%$ :

```{r nc_ds1}
nc <- sum(summary(pca_ds1)$importance[3,] < .999) + 1
nc
```

### Comparing formulas

Choosing from different splines (and/or parameters) can be done with cross-validation (CV) through the use of the `ge_imCV()` function. 
The function inputs the `X`, `p` and a `formula_list` to test. 
Other parameters on the CV itself can also be given (*e.g.* training set size).

Note that the model type is fixed for all formulas in one call of `ge_imCV()`.

`ge_imCV()` computes various indices of model performance. These are computed *by variable* (gene) and then averaged :
the average Correlation Coefficient (`aCC`), the average Relative Error (`aRE`), Mean Squared Error (`MSE`) and average Root MSE (`aRMSE`). 
These indices all compare model predictions and the true data. 
The `ge_imCV()` function computes them on the validation set (CV Error) *and* on the training set (Model PerFormance).

Below is an example of usage to choose between 4 available smooth terms on the `ds1` GEIM.
```{r include = F}
set.seed(10)
```

```{r cv_ds1, cache=quick_build, results='markup'}
smooth_methods <- c("tp", "ts", "cr", "ps")
flist <- as.list(paste0("X ~ s(age, bs = \'", smooth_methods, "\') + strain"))
flist

cv_ds1 <- ge_imCV(X = scale(ds1$g), p = ds1$p, formula_list = flist,
                  cv.n = 20, nc = nc, nb.cores = 3)
```

```{r plot_cv_ds1, fig.width=12, fig.height=8, fig.align='center'}
plot(cv_ds1, names = paste0("bs = ", smooth_methods), outline = F,
     swarmargs = list(cex = .8))
```




From the plots above, the cubic regression spline (`cr`) seems to be the best-performing choice. 

<br>


## Rest of contents coming soon :-)


<hr>